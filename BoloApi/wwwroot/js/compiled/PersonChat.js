"use strict"; function _defineProperty(e, t, s) { return t in e ? Object.defineProperty(e, t, { value: s, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = s, e } class PersonChat extends React.Component { constructor(e) { super(e), _defineProperty(this, "scrollToBottom", () => { void 0 !== this.messagesEnd && null !== this.messagesEnd && this.messagesEnd.scrollIntoView() }); let t = !0, s = this.props.person; null === localStorage.getItem("token") && (t = !1), this.state = { loading: !1, loggedin: t, myself: void 0 !== this.props.myself ? this.props.myself : null, bsstyle: "", message: "", person: s, filestoupload: [], token: null === localStorage.getItem("token") ? "" : localStorage.getItem("token"), textinput: "", dummy: Date.now(), videoCapable: !(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia), peerCapable: SimplePeer.WEBRTC_SUPPORT, videoplaying: !1, audioplaying: !1, showemojimodal: !1, peerconnected: !1, profiletoshow: null, showprofilemodal: !1 }, this.mystream = null, this.otherstream = null, this.peer = null, this.checkPersonPulseInterval = null, this.messages = null !== localStorage.getItem(s.id) ? new Map(JSON.parse(localStorage.getItem(s.id))) : new Map, this.hubConnection = null, this.freader = new FileReader, this.handleChange = this.handleChange.bind(this), this.handleSend = this.handleSend.bind(this), this.sendTextMessage = this.sendTextMessage.bind(this), this.startHub = this.startHub.bind(this), this.createPeer = this.createPeer.bind(this), this.onPeerSignal = this.onPeerSignal.bind(this), this.onPeerConnect = this.onPeerConnect.bind(this), this.onPeerClose = this.onPeerClose.bind(this), this.onPeerError = this.onPeerError.bind(this), this.onPeerStream = this.onPeerStream.bind(this), this.handleVideoToggle = this.handleVideoToggle.bind(this), this.handleAudioToggle = this.handleAudioToggle.bind(this), this.getUserCam = this.getUserCam.bind(this), this.addMedia = this.addMedia.bind(this), this.userMediaError = this.userMediaError.bind(this), this.sayHello = this.sayHello.bind(this), this.answerHello = this.answerHello.bind(this), this.saysHello = this.saysHello.bind(this), this.updateReceivedMessageStatusAll = this.updateReceivedMessageStatusAll.bind(this), this.handleVideoCancel = this.handleVideoCancel.bind(this), this.closeVideo = this.closeVideo.bind(this), this.handleEmojiModal = this.handleEmojiModal.bind(this), this.handleEmojiSelect = this.handleEmojiSelect.bind(this), this.handlePhotoClick = this.handlePhotoClick.bind(this), this.handleDocClick = this.handleDocClick.bind(this), this.handleFileInput = this.handleFileInput.bind(this), this.handleFileChunkUpload = this.handleFileChunkUpload.bind(this), this.processFileUpload = this.processFileUpload.bind(this), this.uploadFile = this.uploadFile.bind(this), this.checkPersonPulse = this.checkPersonPulse.bind(this), this.attachMyStreamToVideo = this.attachMyStreamToVideo.bind(this), this.attachOtherStreamToVideo = this.attachOtherStreamToVideo.bind(this), this.hubConnectionClosed = this.hubConnectionClosed.bind(this), this.hubConnectionReconnecting = this.hubConnectionReconnecting.bind(this), this.hubConnectionReconnected = this.hubConnectionReconnected.bind(this), this.handleProfileModalClose = this.handleProfileModalClose.bind(this), this.handleProfileImageClick = this.handleProfileImageClick.bind(this), this.deleteMyMessagesFromServer = this.deleteMyMessagesFromServer.bind(this), this.updateTextInputHeight = this.updateTextInputHeight.bind(this), this.fetchSentMessages = this.fetchSentMessages.bind(this), this.setMessageStatus = this.setMessageStatus.bind(this), this.messageStatusEnum = { Pending: 0, Sent: 1, Received: 2, Seen: 3 } } hubConnectionClosed(e) { console.log("Hub connection is closed") } hubConnectionReconnecting(e) { console.log("Hub connection is reconnecting") } hubConnectionReconnected(e) { console.log("Hub Connection Reconnected, Check for sent messages on server"), this.fetchSentMessages() } fetchSentMessages() { fetch("//" + window.location.host + "/api/ChatMessages/SentMessages?sender=" + this.state.person.id, { method: "get", headers: { Authorization: "Bearer " + this.state.token } }).then(e => { 200 === e.status && e.json().then(e => { for (var t in console.log(e), e) if (!this.messages.has(e[t].id)) { var s = e[t], a = { id: s.id, sender: s.sentBy.id, text: s.message, timestamp: s.sentDate, status: this.messageStatusEnum.Received }; this.messages.set(a.id, a), this.setMessageStatus(a.id, "SetReceived") } this.setState({ dummy: Date.now() }, () => { localStorage.setItem(this.state.person.id.toLowerCase(), JSON.stringify(Array.from(this.messages.entries()))) }) }) }) } setMessageStatus(e, t) { fetch("//" + window.location.host + "/api/ChatMessages/" + t + "?mid=" + e, { method: "get", headers: { Authorization: "Bearer " + this.state.token } }) } startHub() { this.hubConnection = (new signalR.HubConnectionBuilder).withUrl("/personchathub", { accessTokenFactory: () => this.state.token }).withAutomaticReconnect().build(), this.hubConnection.start().then(() => { console.log("Hub Connection started!"), this.sayHello() }).catch(e => console.log("Error while establishing connection :(")), this.hubConnection.onclose(this.hubConnectionClosed), this.hubConnection.onreconnecting(this.hubConnectionReconnecting), this.hubConnection.onreconnected(this.hubConnectionReconnected), this.hubConnection.on("ReceiveTextMessage", (e, t, s, a) => { this.receiveTextMessage(e, t, s, a) }), this.hubConnection.on("MessageSent", (e, t, s, a) => { var i = { id: a, sender: this.state.myself.id, text: t, timestamp: s, status: this.messageStatusEnum.Sent }; e.toLowerCase() === this.state.person.id.toLowerCase() && (this.messages.set(a, i), this.setState({ dummy: Date.now() }, () => { localStorage.setItem(this.state.person.id.toLowerCase(), JSON.stringify(Array.from(this.messages.entries()))) }), this.scrollToBottom()) }), this.hubConnection.on("MessageStatus", (e, t, s) => { t.toLowerCase() === this.state.person.id.toLowerCase() && void 0 !== this.messages.get(e) && (this.messages.get(e).status = s, this.setState({ dummy: Date.now() }, () => { localStorage.setItem(this.state.person.id.toLowerCase(), JSON.stringify(Array.from(this.messages.entries()))) })) }), this.hubConnection.on("ContactSaved", e => { let t = new Map; null !== localStorage.getItem("contacts") && (t = new Map(JSON.parse(localStorage.getItem("contacts")))), t.set(e.person.id, e), localStorage.setItem("contacts", JSON.stringify(Array.from(t))) }), this.hubConnection.on("ReceiveSignal", (e, t) => { null !== this.peer && this.peer.signal(t) }), this.hubConnection.on("SaysHello", e => { console.log("SaysHello By : " + e), this.saysHello(e) }), this.hubConnection.on("AnswerHello", e => { console.log("Call Answered By : " + e), this.answerHello(e) }), this.hubConnection.on("EndPeer", e => { this.state.person.id.toLowerCase() === e.toLowerCase() && null !== this.peer && (this.peer.destroy(), this.peer = null, console.log("EndPeer By : " + e)) }), this.hubConnection.on("ContactUpdated", e => { this.state.person.id === e.id && this.setState({ person: e }) }) } sayHello() { this.hubConnection.invoke("sayHello", this.state.myself.id.toLowerCase(), this.state.person.id.toLowerCase()).catch(e => { console.log("Unable to say hello."), console.error(e) }) } saysHello(e) { e.toLowerCase() === this.state.person.id.toLowerCase() && (this.createPeer(!0), this.hubConnection.invoke("AnswerHello", e, this.state.myself.id.toLowerCase())) } answerHello(e) { this.state.person.id === e.toLowerCase() && this.createPeer(!1) } sendTextMessage(e, t) { if ("" !== e.trim()) { const s = new FormData; s.set("Text", e), s.set("SentTo", t), s.set("PublicID", "00000000-0000-0000-0000-000000000000"), fetch("//" + window.location.host + "/api/ChatMessages", { method: "post", body: s, headers: { Authorization: "Bearer " + localStorage.getItem("token") } }).then(e => { 401 === e.status ? (localStorage.removeItem("token"), this.setState({ loggedin: !1, loading: !1 })) : 200 === e.status ? e.json().then(e => { console.log(e); var t = { id: e.id, sender: this.state.myself.id, text: e.message, timestamp: e.sentDate, status: this.messageStatusEnum.Sent }; this.messages.set(t.id, t), this.setState({ dummy: Date.now() }, () => { localStorage.setItem(this.state.person.id.toLowerCase(), JSON.stringify(Array.from(this.messages.entries()))), this.updateTextInputHeight() }), this.scrollToBottom() }) : this.setState({ loading: !1, message: "Unable to send message", bsstyle: "danger" }) }), this.detectXtralargeScreen() && this.textinput.focus() } } receiveTextMessage(e, t, s, a) { var i = { id: a, sender: e, text: t, timestamp: s, status: this.messageStatusEnum.Seen }; e.toLowerCase() === this.state.person.id.toLowerCase() ? (this.messages.set(a, i), this.setState({ dummy: Date.now() }, () => { localStorage.setItem(this.state.person.id.toLowerCase(), JSON.stringify(Array.from(this.messages.entries()))) }), this.scrollToBottom(), this.playmsgbeep(), this.setMessageStatus(i.id, "SetSeen")) : void 0 !== this.props.receivedMessage && this.props.receivedMessage(i) } checkPersonPulse() { var e = new Date(this.state.person.lastPulse); if (e.setSeconds(e.getSeconds() + 5), e < Date.now()) { let e = this.state.person; e.activity = 5, this.setState({ person: e }) } } detectEdgeorIE() { const e = !!document.documentMode, t = !e && !!window.StyleMedia; return e || t } detectXtralargeScreen() { return window.matchMedia("(min-width: 1024px)").matches } createPeer(e) { let t = { iceServers: [{ urls: "stun:stun.services.mozilla.com" }, { urls: "stun:stun.l.google.com:19302" }] }; "localhost" === window.location.hostname.toLowerCase() && (t = {}), console.log("newuserarrived stream : "), console.log(this.mystream), this.peer = new SimplePeer({ initiator: e, config: t, stream: this.mystream }), this.peer.on("error", this.onPeerError), this.peer.on("signal", this.onPeerSignal), this.peer.on("connect", this.onPeerConnect), this.peer.on("close", this.onPeerClose), this.peer.on("stream", e => { this.onPeerStream(e) }), this.peer.on("data", e => { console.log("got a message from peer1: " + e) }) } onPeerSignal(e) { this.hubConnection.invoke("SendSignal", e, this.state.person.id, this.state.myself.id).catch(e => console.error("SendSignal " + e)) } onPeerConnect() { this.peer.send(this.state.myself.name + " peer connected.") } onPeerError(e) { console.log(this.state.person.name + " peer gave error. "), console.error(e) } onPeerClose() { console.log("Peer Closed"), this.hubConnection.invoke("EndPeer", this.state.myself.id.toLowerCase(), this.state.person.id.toLowerCase()).catch(e => console.error("Endpeer " + e)) } onPeerStream(e) { console.log("received a stream"), console.log(e), this.otherstream = e, this.setState({ dummydate: Date.now() }, () => { let e = document.getElementById("othervideo"); null !== e && ("srcObject" in e ? e.srcObject = this.otherstream : e.src = window.URL.createObjectURL(this.otherstream), e.muted = !1, e.volume = .8, e.play()) }) } playmsgbeep() { try { let e = document.getElementById("chatbeep"); null != e && (e.currentTime = 0, e.volume = .15, e.muted = !1, e.play()) } catch (e) { console.error(e) } } getUserCam() { var e = { audio: !0, video: !0 }; navigator.mediaDevices.getUserMedia && navigator.mediaDevices.getUserMedia(e).then(this.addMedia).catch(this.userMediaError) } addMedia(e) { this.mystream = e, this.setState({ dummydate: new Date }, () => { this.attachMyStreamToVideo() }), this.mystream.getVideoTracks().length > 0 && (this.mystream.getVideoTracks()[0].enabled = this.state.videoplaying), this.mystream.getAudioTracks().length > 0 && (this.mystream.getAudioTracks()[0].enabled = this.state.audioplaying), null !== this.peer && this.peer.addStream(this.mystream) } attachMyStreamToVideo() { if (this.state.videoplaying || this.state.audioplaying) { var e = document.getElementById("myvideo"); null !== e && (e.srcObject = this.mystream, e.onloadedmetadata = function (t) { void 0 !== e && (e.volume = 0, e.muted = 0, e.play()) }) } } attachOtherStreamToVideo() { var e = document.getElementById("othervideo"); null !== e && (e.srcObject = this.otherstream, e.onloadedmetadata = function (t) { void 0 !== e && (e.volume = 0, e.muted = 0, e.play()) }) } userMediaError(e) { console.log("Unable to access user media"), console.error(e), void 0 !== e.name && null !== e.name && ("notallowederror" === e.name.toLowerCase() ? alert("You have specifically denied access to camera and microphone. Please check browser title or address bar to see the notification.") : alert("Unable to access camera.")), this.setState({ videoplaying: !1, audioplaying: !1 }) } closeVideo() { this.mystream } showMessageStatus(e) { switch (e) { case this.messageStatusEnum.Received: return "Received"; case this.messageStatusEnum.Sent: return "Sent"; case this.messageStatusEnum.Seen: return "Seen"; default: return "" } } updateReceivedMessageStatusAll() { for (const [e, t] of this.messages.entries()) t.sender !== this.state.myself.id && t.status !== this.messageStatusEnum.Seen && (this.messages.get(e).status = this.messageStatusEnum.Seen, this.setMessageStatus(t.id, "SetSeen")); localStorage.setItem(this.state.person.id.toLowerCase(), JSON.stringify(Array.from(this.messages.entries()))) } deleteMyMessagesFromServer() { fetch("//" + window.location.host + "/api/chatmessages/MemberMessages/" + this.state.person.id, { method: "post", headers: { Authorization: "Bearer " + localStorage.getItem("token") } }).then(e => { 200 === e.status && console.log("messages deleted from server") }) } processFileUpload() { let e = null; this.state.filestoupload.length > 0 && (e = this.state.filestoupload[0]), null !== e && (this.freader = new FileReader, this.freader.uploadFile = this.uploadFile, this.uploadFile(this.state.id, e, 0)) } uploadFile(e, t, s) { var a = s + 1024e3 + 1, i = t.filedata.slice(s, a); this.freader.onloadend = (e => { e.target.readyState === FileReader.DONE && this.handleFileChunkUpload(e.target.result, t, s, a, 1024e3) }), this.freader.readAsDataURL(i) } updateTextInputHeight() { if ("" !== this.state.textinput) { this.textinput.style.height = "inherit"; const e = window.getComputedStyle(this.textinput); parseInt(e.getPropertyValue("border-top-width"), 10), parseInt(e.getPropertyValue("padding-top"), 10), this.textinput.scrollHeight, parseInt(e.getPropertyValue("padding-bottom"), 10), parseInt(e.getPropertyValue("border-bottom-width"), 10); this.textinput.style.minHeight = `${this.textinput.scrollHeight}px` } else this.textinput.style.height = "40px", this.textinput.style.minHeight = "40px" } handleFileChunkUpload(e, t, s, a, i) { const o = new FormData; o.set("f", e), o.set("filename", t.name), o.set("gfn", !1), fetch("//" + window.location.host + "/api/members/uploadfile", { method: "post", body: o, headers: { Authorization: "Bearer " + localStorage.getItem("token") } }).then(e => { 200 === e.status && e.json().then(e => { t.serverfname = e.filename; let o = this.state.filestoupload; for (var n = 0; o.length > n; n++) { let e = o[n]; if (e.name === t.name) { var l = s + i; t.progresspercent = Math.floor(l / t.filedata.size * 100), e.progresspercent = t.progresspercent, a > t.filedata.size ? (o.splice(n, 1), t.filedata = null, this.sendTextMessage("https://" + window.location.host + "/data/" + this.state.myself.id + "/" + t.serverfname, this.state.person.id), this.setState({ filestoupload: o }), this.generateVideoThumbnail(t.serverfname), this.processFileUpload()) : (this.setState({ filestoupload: o }), this.uploadFile(this.state.id, t, a)); break } } }) }) } generateVideoThumbnail(e) { fetch("//" + window.location.host + "/api/members/GenerateThumbnail?filename=" + e, { headers: { Authorization: "Bearer " + localStorage.getItem("token") } }) } handlePhotoClick(e) { e.preventDefault(), this.state.loggedin ? this.fileinput.click() : alert("Log in to use this feature. Share files upto 300 MB in size.") } handleDocClick(e) { e.preventDefault(), this.state.loggedin ? this.fileinput.click() : alert("Log in to use this feature. Share files upto 300 MB in size.") } handleFileUploadCancel(e, t) { let s = this.state.filestoupload; for (var a = 0; s.length > a; a++) { if (s[a].name === t) { s.splice(a, 1), this.setState({ filestoupload: s }); break } } } handleFileInput(e) { if (this.fileinput.files.length > 10) return void alert("Only 10 files at a time."); for (var t = 0; t < this.fileinput.files.length; t++)if ((this.fileinput.files[t].size / 1048576).toFixed(1) > 300) return void alert("File size cannot exceed 300 MB"); let s = this.state.filestoupload; for (t = 0; t < this.fileinput.files.length; t++) { let e = { name: this.fileinput.files[t].name, filedata: this.fileinput.files[t], progresspercent: 0, serverfname: "", cancel: !1 }; s.push(e) } this.setState({ filestoupload: s }), this.fileinput.value = "", this.processFileUpload() } handleEmojiSelect(e) { this.setState({ textinput: this.state.textinput + e }), this.textinput.focus() } handleEmojiModal() { this.setState({ showemojimodal: !this.state.showemojimodal }) } handleVideoCancel() { this.closeVideo(), this.hubConnection.invoke("EndCall", this.state.myself.id.toLowerCase(), this.state.person.id.toLowerCase()).catch(e => { console.log("Unable to end call."), console.error(e) }) } handleChange(e) { switch (e.target.name) { case "textinput": this.setState({ textinput: e.target.value }, () => { this.updateTextInputHeight() }) } } handleSend(e) { e.preventDefault(), this.sendTextMessage(this.state.textinput, this.state.person.id), this.setState({ textinput: "" }) } handleVideoToggle(e) { null !== this.mystream ? this.mystream.getVideoTracks().length > 0 && (this.mystream.getVideoTracks()[0].enabled = !this.state.videoplaying, this.setState({ videoplaying: !this.state.videoplaying }, () => { this.attachMyStreamToVideo() })) : (this.setState({ videoplaying: !0, audioplaying: !0 }), this.getUserCam()) } handleAudioToggle(e) { null !== this.mystream ? this.mystream.getAudioTracks().length > 0 && (this.mystream.getAudioTracks()[0].enabled = !this.state.audioplaying, this.setState({ audioplaying: !this.state.audioplaying }, () => { this.attachMyStreamToVideo() })) : (this.getUserCam(), this.setState({ audioplaying: !0 })) } handleProfileModalClose() { this.setState({ profiletoshow: null, showprofilemodal: !1 }) } handleProfileImageClick(e) { this.setState({ profiletoshow: this.state.person, showprofilemodal: !0 }) } componentDidMount() { this.startHub(), this.scrollToBottom(), this.updateReceivedMessageStatusAll(), this.deleteMyMessagesFromServer(), this.checkPersonPulseInterval = setInterval(this.checkPersonPulse, 5e3); let e = null !== localStorage.getItem("contacts") ? new Map(JSON.parse(localStorage.getItem("contacts"))) : new Map; void 0 !== e.get(this.state.person.id.toLowerCase()) && (e.get(this.state.person.id.toLowerCase()).unseenMessageCount = 0), localStorage.setItem("contacts", JSON.stringify(Array.from(e))) } componentWillUnmount() { null !== this.peer && (this.peer.destroy(), this.peer = null), this.hubConnection.stop(), null !== this.checkPersonPulseInterval && clearInterval(this.checkPersonPulseInterval) } renderEmojiModal() { return this.state.showemojimodal ? React.createElement("div", { style: { position: "fixed", bottom: "42px", right: "0px" } }, React.createElement(Emoji, { onSelect: this.handleEmojiSelect })) : null } getFileExtensionBasedName(e) { return e.substring(61, e.length) } renderVideoCallModal() { return React.createElement("div", { className: "modal d-block", "data-backdrop": "static", "data-keyboard": "false", tabIndex: "-1", role: "dialog", "aria-labelledby": "staticBackdropLabel", "aria-hidden": "true" }, React.createElement("div", { className: "modal-dialog" }, React.createElement("div", { className: "modal-content" }, React.createElement("div", { className: "modal-body" }, React.createElement("h4", null, "Waiting For ", this.state.person.name), React.createElement("button", { type: "button", className: "btn btn-danger btn-lg", onClick: this.handleVideoCancel }, "Cancel"))))) } renderLinksInMessage(e) { var t = e.id; return e.text.startsWith("https://" + window.location.host + "/data/") ? e.text.toLowerCase().endsWith(".jpg") || e.text.toLowerCase().endsWith(".jpeg") || e.text.toLowerCase().endsWith(".png") || e.text.toLowerCase().endsWith(".gif") || e.text.toLowerCase().endsWith(".bmp") ? React.createElement("span", { id: t }, React.createElement("img", { src: e.text, className: "img-fluid d-block mt-1 mb-1 img-thumbnail", style: { maxWidth: "260px" } })) : e.text.toLowerCase().endsWith(".mp3") ? React.createElement("span", { id: t }, React.createElement("audio", { src: e.text, controls: !0, playsInline: !0, style: { maxWidth: "260px" } })) : e.text.toLowerCase().endsWith(".ogg") || e.text.toLowerCase().endsWith(".mp4") || e.text.toLowerCase().endsWith(".webm") || e.text.toLowerCase().endsWith(".mov") ? React.createElement("span", { id: t }, React.createElement("video", { src: e.text.toLowerCase(), controls: !0, playsInline: !0, style: { maxWidth: "260px" } })) : React.createElement("span", { id: t }, React.createElement("a", { href: e.text, target: "_blank" }, React.createElement("img", { src: "/icons/download-cloud.svg", className: "img-fluid", title: "download file" }), React.createElement("br", null), this.getFileExtensionBasedName(e.text.toLowerCase()))) : (e.text.startsWith("https://") || e.text.startsWith("http://")) && -1 === e.text.trim().indexOf(" ") ? React.createElement("span", { id: t }, React.createElement("a", { href: e.text.trim(), target: "_blank" }, e.text)) : React.createElement("span", { id: t }, e.text.split("\n").map((e, t) => React.createElement(React.Fragment, { key: t }, e, React.createElement("br", null)))) } renderMessages() { let e = { display: "block", textAlign: "right" }, t = { display: "block", textAlign: "left" }, s = { margin: "4px", maxWidth: "80%", position: "relative", padding: ".2rem", fontSize: "1rem", border: "none", borderRadius: ".25rem", display: "inline-block", color: "#000", backgroundColor: "#DBF4FD", wordWrap: "break-word" }, a = { margin: "4px", maxWidth: "80%", position: "relative", padding: ".2rem", border: "none", borderRadius: ".25rem", fontSize: "1rem", display: "inline-block", color: "#000", backgroundColor: "#F2F6F9", wordWrap: "break-word" }; const i = []; for (const [o, n] of this.messages.entries()) n.sender === this.state.myself.id ? i.push(React.createElement("li", { style: e, key: o }, React.createElement("div", { style: s }, this.renderLinksInMessage(n), React.createElement("span", { className: "d-block" }, React.createElement("small", { style: { fontSize: "0.75rem" } }, moment(n.timestamp.replace(" UTC", "")).fromNow(!0)), " ", React.createElement("small", { style: { fontSize: "0.75rem" } }, this.showMessageStatus(n.status)))))) : i.push(React.createElement("li", { style: t, key: o }, React.createElement("div", { style: a, className: "alert alert-info" }, this.renderLinksInMessage(n), React.createElement("span", { className: "d-block" }, React.createElement("small", { style: { fontSize: "0.75rem" } }, moment(n.timestamp.replace(" UTC", "")).fromNow(!0)))))); return React.createElement(React.Fragment, null, i, React.createElement("li", { style: { float: "left", clear: "both" }, ref: e => { this.messagesEnd = e } })) } renderVideo() { let e = "full", t = null, s = null, a = !1; if (null !== this.otherstream) { for (var i = 0; i < this.otherstream.getTracks().length; i++)if (this.otherstream.getTracks()[i].enabled) { a = !0; break } a && (e = "docked", t = React.createElement("video", { id: "othervideo", muted: "muted", volume: "0", playsInline: !0, style: { maxWidth: "100%", maxHeight: "70vh" } })) } if (null !== this.mystream) { a = !1; for (i = 0; i < this.mystream.getTracks().length; i++)if (this.mystream.getTracks()[i].enabled) { a = !0; break } a && (s = React.createElement("video", { id: "myvideo", className: e, muted: "muted", volume: "0", playsInline: !0, style: { maxWidth: "100%", maxHeight: "70vh" } })) } return null !== t || null !== s ? React.createElement("div", { className: "col col-sm-7 videochatcolumn", style: { padding: "0px 5px", textAlign: "center" } }, t, s) : null } renderFileUploadProcessModal() { let e = []; for (var t = 0; t < this.state.filestoupload.length; t++) { let s = this.state.filestoupload[t]; e.push(React.createElement("div", { className: "row", key: t }, React.createElement("div", { className: "col-9 col-xl-10 col-sm-10" }, React.createElement("div", { className: "progress" }, React.createElement("div", { className: "progress-bar progress-bar-animated", role: "progressbar", "aria-valuenow": s.progresspercent, "aria-valuemin": "0", "aria-valuemax": "100", style: { width: s.progresspercent + "%" } }))), React.createElement("div", { className: "col-3 col-xl-2 col-sm-2" }, React.createElement("button", { type: "button", className: "btn btn-sm btn-light", onClick: e => this.handleFileUploadCancel(e, s.name) }, "Cancel")))) } return this.state.filestoupload.length > 0 ? React.createElement(React.Fragment, null, React.createElement("div", { className: "modal d-block", "data-backdrop": "static", "data-keyboard": "false", tabIndex: "-1", role: "dialog", "aria-labelledby": "staticBackdropLabel", "aria-hidden": "true" }, React.createElement("div", { className: "modal-dialog" }, React.createElement("div", { className: "modal-content" }, React.createElement("div", { className: "modal-body" }, e))))) : null } render() { 0 == this.messages.length && (profile = React.createElement(ViewProfile, { profile: this.state.person })); let e = React.createElement("img", { src: "/images/nopic.jpg", className: "mx-auto d-block img-fluid", alt: "No Pic", style: { cursor: "pointer" }, onClick: this.handleProfileImageClick }); null !== this.state.person && "" !== this.state.person.pic && (e = React.createElement("img", { src: this.state.person.pic, className: "mx-auto d-block img-fluid", alt: "", style: { cursor: "pointer" }, onClick: this.handleProfileImageClick })); let t = null; null !== this.state.profiletoshow && this.state.showprofilemodal && (t = React.createElement("div", { className: "modal d-block", tabIndex: "-1", role: "dialog" }, React.createElement("div", { className: "modal-dialog modal-dialog-scrollable" }, React.createElement("div", { className: "modal-content" }, React.createElement("div", { className: "modal-body" }, React.createElement("button", { type: "button", className: "close float-right", "data-dismiss": "modal", "aria-label": "Close", onClick: this.handleProfileModalClose }, React.createElement("span", { "aria-hidden": "true" }, "×")), React.createElement(ViewProfile, { profile: this.state.person })))))); let s = this.state.videoplaying ? React.createElement("button", { type: "button", className: "btn btn-sm btn-primary mr-1 ml-1 videoctrl", onClick: this.handleVideoToggle, onMouseDown: e => e.stopPropagation() }, React.createElement("img", { src: "/icons/video.svg", alt: "", width: "24", height: "24", title: "Video On" })) : React.createElement("button", { type: "button", className: "btn btn-secondary btn-sm mr-1 ml-1 videoctrl", onClick: this.handleVideoToggle, onMouseDown: e => e.stopPropagation() }, React.createElement("img", { src: "/icons/video.svg", alt: "", width: "24", height: "24", title: "Video Off" })), a = this.state.audioplaying ? React.createElement("button", { type: "button", className: "btn btn-primary btn-sm mr-1 ml-1 audioctrl", onClick: this.handleAudioToggle, onMouseDown: e => e.stopPropagation() }, React.createElement("img", { src: "/icons/mic.svg", alt: "", width: "24", height: "24", title: "Microphone On" })) : React.createElement("button", { type: "button", className: "btn btn-secondary btn-sm mr-1 ml-1 audioctrl", onClick: this.handleAudioToggle, onMouseDown: e => e.stopPropagation() }, React.createElement("img", { src: "/icons/mic.svg", alt: "", width: "24", height: "24", title: "Microphone Off" })); this.detectEdgeorIE() && (a = null, s = null); let i = React.createElement("span", { className: "offline" }); 5 !== this.state.person.activity && (i = React.createElement("span", { className: "online" })); let o = this.renderVideo(), n = {}; return null === o && this.detectXtralargeScreen() && (n = { padding: "0px 200px" }), React.createElement(React.Fragment, null, React.createElement("div", { className: "personalchatcont" }, React.createElement("table", { className: "chatpersoninfocont sticky-top" }, React.createElement("tbody", null, React.createElement("tr", null, React.createElement("td", { width: "40px", align: "right" }, React.createElement("button", { type: "button", className: "btn btn-light", onClick: () => this.props.handleShowSearch(!0) }, "❮")), React.createElement("td", { width: "40px", className: "noPadding" }, e), React.createElement("td", { className: "noPadding" }, React.createElement("h5", { className: "ml-1", style: { maxWidth: "150px", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }, title: this.state.person.name }, i, " ", this.state.person.name)), React.createElement("td", { width: "37px" }, React.createElement("li", { className: "list-inline-item" }, React.createElement("div", { className: "dropdown" }, React.createElement("a", { className: "btn btn-light btn-sm dropdown-toggle", href: "#", role: "button", id: "navbarDropdown", "data-toggle": "dropdown", "aria-haspopup": "true", "aria-expanded": "false" }, React.createElement("img", { src: "/icons/file-plus.svg", alt: "", width: "24", height: "24", title: "Share Files" })), React.createElement("div", { className: "dropdown-menu dropdown-menu-right", "aria-labelledby": "navbarDropdown" }, React.createElement("a", { className: "dropdown-item", href: "#", onClick: this.handlePhotoClick, title: "20 Files at a time, max files size 10 MB" }, "Photos and Videos"), React.createElement("a", { className: "dropdown-item", href: "#", onClick: this.handleDocClick, title: "20 Files at a time, max files size 10 MB" }, "Documents"), React.createElement("input", { type: "file", style: { display: "none" }, ref: e => { this.fileinput = e }, accept: ".html,.htm,.doc,.pdf,.xls,.xlsx,.docx,audio/*,video/*,image/*", onChange: this.handleFileInput, multiple: "multiple" }))))), React.createElement("td", { width: "37px" }, s), React.createElement("td", { width: "37px" }, a)))), React.createElement("div", { className: "videochatcont container-fluid" }, React.createElement("div", { className: "row" }, o, React.createElement("div", { className: "col-sm border-left", style: { padding: "0px 5px" } }, React.createElement("div", { className: "chatmsgcont", style: n }, React.createElement("ul", { className: "list-unstyled" }, this.renderMessages()))))), React.createElement("form", { onSubmit: this.handleSend }, React.createElement("div", { className: "border-top chatinputcontainer", style: { position: "relative", height: "40px" } }, React.createElement("textarea", { ref: e => { this.textinput = e }, name: "textinput", autoComplete: "off", accessKey: "t", title: "Keyboard Shortcut ALT + t", className: "form-control", value: this.state.textinput, onChange: this.handleChange, width: "100%", style: { height: "40px", overflow: "hidden", resize: "none", position: "absolute", bottom: "0px", left: "0px", maxHeight: "200px" } }), React.createElement("button", { type: "button", className: this.state.showemojimodal ? "btn btn-sm btn-warning d-none d-sm-block" : "btn btn-sm btn-light d-none d-sm-block", onClick: this.handleEmojiModal, style: { position: "absolute", right: "50px", bottom: "3px" }, accessKey: "o", title: "Keyboard Shortcut ALT + o" }, React.createElement("img", { src: "/icons/smile.svg", alt: "", width: "24", height: "24" })), React.createElement("button", { type: "submit", id: "msgsubmit", className: "btn btn-sm btn-dark ", title: "Send Message", style: { position: "absolute", right: "5px", bottom: "3px" }, title: "Keyboard Shortcut ALT + s", accessKey: "s" }, React.createElement("img", { src: "/icons/send.svg", alt: "", width: "24", height: "24" })))), this.renderEmojiModal()), t, this.renderFileUploadProcessModal(), React.createElement("audio", { id: "chatbeep", muted: "muted", volume: "0" }, React.createElement("source", { src: "/media/swiftly.mp3" }), React.createElement("source", { src: "/media/swiftly.m4r" }), React.createElement("source", { src: "/media/swiftly.ogg" })), React.createElement(HeartBeat, { activity: "4", interval: "3000" })) } }